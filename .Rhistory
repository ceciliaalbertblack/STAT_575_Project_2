setwd("C:/Users/q4q/OneDrive - Oak Ridge National Laboratory/Research/Bioavailability Project/2. Time Series Analysis/STIC Sensor Data/Data Cleaning/Cubic Spline Interpolation Method")
library(readxl)
mca1_dat <- read_excel("mca1_bioavail_interpolation.xlsx")
View(mca1_dat)
str(mca1_dat)
library(dplyr)
library(lubridate)
daily_avg <- mca1_dat %>%
mutate(Date = as.Date(DateTime)) %>%         # extract date
group_by(Site, Date) %>%                     # group by site and day
summarise(across(where(is.numeric), mean, na.rm = TRUE)) %>%  # daily means
ungroup()
# Check result
head(daily_avg)
library(dplyr)
# Select variables
subset_daily_avg <- daily_avg %>%
select(Date, Meas_Zn_nM, Temp_C, pH, DOC_M, DIC_mM, Ca_uM, Mg_uM, Na_uM, K_uM,
SO4_uM, Cl_uM)
# Preview
head(subset_daily_avg)
library(tidyverse)
# Pivot only numeric columns
subset_long <- subset_daily_avg %>%
pivot_longer(
cols = where(is.numeric),     # only numeric variables
names_to = "Variable",
values_to = "Value"
) %>%
mutate(Source = "Original")      # placeholder, can add "Interpolated" if you have that
# Plot
ggplot(subset_long, aes(x = Date, y = Value)) +
geom_point(data = filter(subset_long, Source == "Original"), size = 1.5, alpha = 0.8) +
# geom_line(data = filter(subset_long, Source == "Interpolated"), linewidth = 0.8) +
facet_wrap(~ Variable, scales = "free_y", ncol = 2) +
scale_x_date(
date_breaks = "1 month",
date_labels = "%b\n%Y"
) +
labs(
x = "Date",
y = "Value",
color = "Data Source",
title = "Daily Averages of Bioavailable Variables"
) +
theme_bw(base_size = 11) +
theme(
legend.position = "top",
strip.background = element_rect(fill = "gray90"),
strip.text = element_text(face = "bold"),
panel.grid.minor = element_blank(),
axis.text.x = element_text(angle = 45, hjust = 1),
panel.spacing = unit(1.0, "lines")  # increases spacing between panels vertically
)
variable_plots <- ggplot(subset_long, aes(x = Date, y = Value)) +
geom_point(data = filter(subset_long, Source == "Original"), size = 1.5, alpha = 0.8) +
# geom_line(data = filter(subset_long, Source == "Interpolated"), linewidth = 0.8) +
facet_wrap(~ Variable, scales = "free_y", ncol = 2) +
scale_x_date(
date_breaks = "1 month",
date_labels = "%b\n%Y"
) +
labs(
x = "Date",
y = "Value",
color = "Data Source",
title = "Daily Averages of Bioavailable Variables"
) +
theme_bw(base_size = 11) +
theme(
legend.position = "top",
strip.background = element_rect(fill = "gray90"),
strip.text = element_text(face = "bold"),
panel.grid.minor = element_blank(),
axis.text.x = element_text(angle = 45, hjust = 1),
panel.spacing = unit(1.0, "lines")
)
library(tidyverse)
# Pivot only numeric columns
subset_long <- subset_daily_avg %>%
pivot_longer(
cols = where(is.numeric),     # only numeric variables
names_to = "Variable",
values_to = "Value"
) %>%
mutate(Source = "Original")      # placeholder, can add "Interpolated" if you have that
# Plot
variable_plots <- ggplot(subset_long, aes(x = Date, y = Value)) +
geom_point(data = filter(subset_long, Source == "Original"), size = 1.5, alpha = 0.8) +
# geom_line(data = filter(subset_long, Source == "Interpolated"), linewidth = 0.8) +
facet_wrap(~ Variable, scales = "free_y", ncol = 2) +
scale_x_date(
date_breaks = "1 month",
date_labels = "%b\n%Y"
) +
labs(
x = "Date",
y = "Value",
color = "Data Source",
title = "Daily Averages of Bioavailable Variables"
) +
theme_bw(base_size = 11) +
theme(
legend.position = "top",
strip.background = element_rect(fill = "gray90"),
strip.text = element_text(face = "bold"),
panel.grid.minor = element_blank(),
axis.text.x = element_text(angle = 45, hjust = 1),
panel.spacing = unit(1.0, "lines")
)
# Export
ggsave("Variable_plots.png", plot = variable_plots)
n <- length(subset_daily_avg$Date)
n
model <- lm(Meas_Zn_nM ~ Temp_C + pH + DOC_M + DIC_mM + Ca_uM + Mg_uM + Na_uM + K_uM + SO4_uM + Cl_uM, data = subset_daily_avg)
# Base R diagnostic plot
diagnostic_plot <- plot(model, which = 1)
# generally homoscedastic with a couple outliers
# Export
ggsave("Diagnostic_plot_of_mlr.png", plot = diagnostic_plot)
model <- lm(Meas_Zn_nM ~ Temp_C + pH + DOC_M + DIC_mM + Ca_uM + Mg_uM + Na_uM + K_uM + SO4_uM + Cl_uM, data = subset_daily_avg)
# Base R diagnostic plot
diagnostic_plot <- plot(model, which = 1)
# generally homoscedastic with a couple outliers
# Export
ggsave("Diagnostic_plot_of_mlr.png", plot = diagnostic_plot)
model <- lm(Meas_Zn_nM ~ Temp_C + pH + DOC_M + DIC_mM + Ca_uM + Mg_uM + Na_uM + K_uM + SO4_uM + Cl_uM, data = subset_daily_avg)
# Base R diagnostic plot
diagnostic_plot <- plot(model, which = 1)
# View
diagnostic_plot
# Notes: generally homoscedastic with a couple outliers
# Export
ggsave("Diagnostic_plot_of_mlr.png", plot = diagnostic_plot)
model <- lm(Meas_Zn_nM ~ Temp_C + pH + DOC_M + DIC_mM + Ca_uM + Mg_uM + Na_uM + K_uM + SO4_uM + Cl_uM, data = subset_daily_avg)
# Base R diagnostic plot
diagnostic_plot <- plot(model, which = 1)
# View
diagnostic_plot
# Notes: generally homoscedastic with a couple outliers
# Export
png("Diagnostic_plot_of_mlr.png",
model <- lm(Meas_Zn_nM ~ Temp_C + pH + DOC_M + DIC_mM + Ca_uM + Mg_uM + Na_uM + K_uM + SO4_uM + Cl_uM, data = subset_daily_avg)
# Base R diagnostic plot
diagnostic_plot <- plot(model, which = 1)
# View
diagnostic_plot
# Notes: generally homoscedastic with a couple outliers
# Export
png("Diagnostic_plot_of_mlr.png")
model <- lm(Meas_Zn_nM ~ Temp_C + pH + DOC_M + DIC_mM + Ca_uM + Mg_uM + Na_uM + K_uM + SO4_uM + Cl_uM, data = subset_daily_avg)
# Base R diagnostic plot
diagnostic_plot <- plot(model, which = 1)
# View
diagnostic_plot
# Notes: generally homoscedastic with a couple outliers
# Remove date column
subset_daily_avg$Date <- NULL
library(tibble)
summary_table <- tibble(
Variable = c("y_t", "x_1t", "x_2t", "x_3t", "x_4t", "x_5t", "x_6t",
"x_7t", "x_8t", "x_9t", "x_10t"),
ID = colnames(subset_daily_avg),
Description = c("Measured Zinc",
"Temp",
"pH",
"Dissolved organic carbon",
"Dissolved inrganic carbon",
"Calcium",
"Magnesium",
"Sodium",
"Potassium",
"Sulfate",
"Chloride"),
Unit = c("uM", "Celsius", "", "M", "mM", "uM", "uM", "uM", "uM", "uM", "uM")
)
# View
summary_table
# Export
library(writexl)
write_xlsx(summary_table, path = "Summary_table_variables.xlsx")
library(tidyverse)
library(combinat)  # for generating all subsets
library(sandwich)  # HAC covariance
library(lmtest)    # coeftest
# ---------------- User controls ----------------
data <- subset_daily_avg
y_var <- "Meas_Zn_nM"
predictors <- setdiff(colnames(data), y_var)  # exclude response
addIntercept <- TRUE
topN <- 1
hacLag <- NULL     # auto lag if NULL
# ---------------- Enumerate all subsets ----------------
p <- length(predictors)
all_subsets <- unlist(lapply(0:p, function(k) combn(p, k, simplify=FALSE)), recursive=FALSE)
results <- vector("list", length(all_subsets))
T_obs <- nrow(data)
hacLag_auto <- ifelse(is.null(hacLag), floor(4*(T_obs/100)^(2/9)), hacLag)
for(i in seq_along(all_subsets)){
idx <- all_subsets[[i]]
X_vars <- predictors[idx]
formula_str <- if(length(X_vars)==0) paste0(y_var," ~ 1") else paste0(y_var," ~ ",paste(X_vars,collapse="+"))
fit <- lm(as.formula(formula_str), data=data)
# ---------------- HAC covariance ----------------
cov_HAC <- tryCatch({
sandwich::vcovHAC(fit, prewhite=FALSE, adjust=TRUE)
}, error=function(e) vcov(fit))  # fallback to standard covariance
# ---------------- Residual variance ----------------
e <- resid(fit)
sig2 <- sum(e^2)/T_obs
k <- length(coef(fit))
# ---------------- AIC / BIC ----------------
AICv <- AIC(fit)
BICv <- BIC(fit)
# ---------------- CIC metric ----------------
ev <- eigen(cov_HAC, symmetric=TRUE, only.values=TRUE)$values
evbar <- mean(ev)
if(!is.finite(evbar) || evbar <= 0) evbar <- mean(ev[ev>0])
C1F <- (1/(4*(evbar^2))) * sum((ev - evbar)^2)
CICv <- T_obs*log(2*pi) + T_obs*log(max(sig2, .Machine$double.eps)) + T_obs + k + 2*log(T_obs)*C1F
results[[i]] <- tibble(
Size = length(X_vars),
Indices = if(length(X_vars)==0) "" else paste(X_vars, collapse=","),
AIC = AICv,
BIC = BICv,
CICOMP = CICv
)
if(i %% 100 == 0) message("Processed subset ", i, " / ", length(all_subsets))
}
res_df <- bind_rows(results)
# ---------------- Top-N subsets ----------------
TopAIC  <- res_df %>% arrange(AIC) %>% slice(1:topN)
TopBIC  <- res_df %>% arrange(BIC) %>% slice(1:topN)
TopCIC  <- res_df %>% arrange(CICOMP) %>% slice(1:topN)
# ---------------- Export CSV ----------------
write_csv(res_df, paste0("ALL_SUBSETS_HAC_", Sys.Date(), ".csv"))
write_csv(bind_rows(
TopAIC %>% mutate(Criterion="AIC"),
TopBIC %>% mutate(Criterion="BIC"),
TopCIC %>% mutate(Criterion="CICOMP")
), paste0("TOP_SUBSETS_HAC_", Sys.Date(), ".csv"))
# ---------------- Quick bar plot ----------------
best_vals <- c(AIC=TopAIC$AIC[1], BIC=TopBIC$BIC[1], CICOMP=TopCIC$CICOMP[1])
barplot(best_vals, main="Best-by-criterion (HAC)",
ylab="Criterion value", col=c("skyblue","orange","green"))
# ---------------- Trajectories vs model size ----------------
sz <- 0:p
bestBySize_AIC <- sapply(sz, function(m) min(res_df$AIC[res_df$Size==m], na.rm=TRUE))
bestBySize_BIC <- sapply(sz, function(m) min(res_df$BIC[res_df$Size==m], na.rm=TRUE))
bestBySize_CIC <- sapply(sz, function(m) min(res_df$CICOMP[res_df$Size==m], na.rm=TRUE))
matplot(sz, cbind(bestBySize_AIC, bestBySize_BIC, bestBySize_CIC), type="b", pch=1:3, lty=1,
xlab="Subset size", ylab="Best value at size", col=c("blue","red","green"))
legend("topright", legend=c("AIC","BIC","CICOMP"), col=c("blue","red","green"), pch=1:3)
library(dplyr)
library(stringr)
topN <- 3
# Combine top-N subsets for each criterion
TopAll <- bind_rows(
TopAIC %>% slice_min(AIC, n = topN) %>% mutate(Criterion="AIC", Information_Criteria=AIC),
TopBIC %>% slice_min(BIC, n = topN) %>% mutate(Criterion="BIC", Information_Criteria=BIC),
TopCIC %>% slice_min(CICOMP, n = topN) %>% mutate(Criterion="CICOMP", Information_Criteria=CICOMP)
)
# Clean up variable names and handle intercept-only models
TopAll <- TopAll %>%
rowwise() %>%
mutate(Variables = if (Indices == "" | is.na(Indices)) "(Intercept only)" else Indices) %>%
select(Criterion, Size, Variables, Information_Criteria)
# Print table
print(TopAll, n = nrow(TopAll))
library(dplyr)
library(stringr)
topN <- 3
# Combine top-N subsets for each criterion
TopAll <- bind_rows(
TopAIC %>% slice_min(AIC, n = topN) %>% mutate(Criterion="AIC", Information_Criteria=AIC),
TopBIC %>% slice_min(BIC, n = topN) %>% mutate(Criterion="BIC", Information_Criteria=BIC),
TopCIC %>% slice_min(CICOMP, n = topN) %>% mutate(Criterion="CICOMP", Information_Criteria=CICOMP)
)
# Clean up variable names and handle intercept-only models
TopAll <- TopAll %>%
rowwise() %>%
mutate(Variables = if (Indices == "" | is.na(Indices)) "(Intercept only)" else Indices) %>%
select(Criterion, Size, Variables, Information_Criteria)
# Print table
ic_table <- print(TopAll, n = nrow(TopAll))
# Export
library(writexl)
write_xlsx(ic_table, path = "Information_criteria_variables.xlsx")
